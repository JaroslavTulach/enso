//! # Counter
//!
//! Counter type. Uses an internal global value to ensure every instance created has a different
//! value.

use crate::prelude::*;



// ===============
// === Counter ===
// ===============

/// Implements a globally-unique counter.
#[derive(Clone, CloneRef, Copy, Debug, Eq, Hash, Into, PartialEq, Ord, PartialOrd)]
pub struct Counter {
    value: u64,
}

/// Generate a unique value.
impl Default for Counter {
    fn default() -> Self {
        crate::prelude::lazy_static! {
            static ref NEXT: std::sync::atomic::AtomicU64 = Default::default();
        }
        let value = NEXT.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
        debug_assert_ne!(value + 1, 0);
        Self { value }
    }
}



// =================
// === define_id ===
// =================

/// Define a type usable as an ID, with unique values generated by a counter.
///
/// Example usage:
/// ```
/// enso_data_structures::define_id! {
///     /// Example ID type. This macro syntax allows applying doc comments and attribute macros to
///     /// the type being defined.
///     pub struct MyId($);
/// }
///
/// // `default()` produces unique values of the new type.
/// let a: MyId = Default::default();
/// let b: MyId = Default::default();
/// assert_ne!(a, b);
/// ```
#[macro_export]
macro_rules! define_id {
    (
        $(#[$attrs:meta])*
        pub struct $name:ident($);
    ) => {
        $(#[$attrs])*
        #[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq, Ord, PartialOrd)]
        pub struct $name($crate::counter::Counter);

        impl std::fmt::Display for $name {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                std::fmt::Debug::fmt(self, f)
            }
        }

        /// Convert to a raw count, losing counter-type information.
        impl From<$name> for u64 {
            fn from(counter: $name) -> Self {
                counter.0.into()
            }
        }
    };
}



// =============
// === Tests ===
// =============

#[cfg(test)]
mod tests {
    define_id! { pub struct TestIdA($); }
    define_id! { pub struct TestIdB($); }

    #[test]
    fn test_counter() {
        let a0: TestIdA = Default::default();
        let a1: TestIdA = Default::default();
        assert_ne!(a0, a1);

        let b0: TestIdB = Default::default();
        let b1: TestIdB = Default::default();
        assert_ne!(b0, b1);
    }
}
